<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aura Mist | Ritual de Yoga Inmersivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500&family=Playfair+Display:ital,wght@0,400;1,400&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Quicksand', sans-serif;
            color: #fff;
            transition: background-color 1s ease;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #bgCanvas {
            z-index: 1;
            filter: blur(80px);
            opacity: 0;
            transition: opacity 2s ease;
        }

        #bgCanvas.active { opacity: 0.5; }

        #canvas { z-index: 2; }

        .heartbeat-active {
            animation: pulse-global 3s infinite ease-in-out;
        }

        @keyframes pulse-global {
            0%, 100% { filter: brightness(1) contrast(1); transform: scale(1); }
            50% { filter: brightness(1.2) contrast(1.1); transform: scale(1.01); }
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            background: radial-gradient(circle, transparent 60%, rgba(0,0,0,0.9) 100%);
            transition: background 1s ease;
        }

        .bloom-active #canvas {
            filter: contrast(1.1) brightness(1.2) blur(0.5px);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            z-index: 20;
            transition: opacity 1s ease-in-out, visibility 1s;
        }

        .ui-hidden { opacity: 0; visibility: hidden; }

        .top-settings {
            position: absolute;
            top: 1rem;
            right: 1rem;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            align-items: flex-end;
            max-width: 280px;
            max-height: 95vh;
            overflow-y: auto;
            padding: 10px;
            scrollbar-width: none;
        }

        .top-settings::-webkit-scrollbar { display: none; }

        .toggle-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.1rem;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.3s ease;
            cursor: pointer;
            backdrop-filter: blur(15px);
            width: 100%;
            text-align: right;
        }

        .toggle-btn.active {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }

        .slider-group {
            background: rgba(255, 255, 255, 0.07);
            padding: 0.8rem;
            border-radius: 15px;
            width: 100%;
            pointer-events: auto;
            margin-top: 0.3rem;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .slider-label {
            font-size: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1rem;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 0.3rem;
            display: block;
        }

        input[type=range] {
            width: 100%;
            height: 2px;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            margin-bottom: 0.6rem;
        }

        input[type=range]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .palette-group {
            pointer-events: auto;
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-bottom: 1rem;
        }

        .palette-btn {
            padding: 0.4rem 0.8rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.6rem;
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            transition: all 0.4s ease;
            cursor: pointer;
        }

        .palette-btn.active {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.8);
            color: #fff;
        }

        .breath-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 220px;
            height: 220px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .breath-guide.active {
            opacity: 1;
            animation: breathe 8s infinite ease-in-out;
        }

        @keyframes breathe {
            0%, 100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.1; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.3; }
        }

        #denouement {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 100; opacity: 0;
            pointer-events: none; transition: opacity 3s ease;
            display: flex; align-items: center; justify-content: center;
        }

        #denouement.active { opacity: 1; pointer-events: auto; }

        .section-title {
            font-size: 0.45rem; text-transform: uppercase;
            letter-spacing: 0.15rem; color: rgba(255, 255, 255, 0.3);
            margin-top: 0.8rem; margin-bottom: 0.2rem;
            width: 100%; text-align: right;
        }

        .water-distort {
            filter: url(#water-filter);
        }
        
        .hidden { display: none; }
    </style>
</head>
<body class="bloom-active">

    <svg style="display:none">
        <defs>
            <filter id="water-filter">
                <feTurbulence type="fractalNoise" baseFrequency="0.01 0.01" numOctaves="1" result="warp" />
                <feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="30" in="SourceGraphic" in2="warp" />
            </filter>
        </defs>
    </svg>

    <div id="vignette" class="vignette"></div>
    <canvas id="bgCanvas"></canvas>
    <canvas id="canvas"></canvas>

    <div id="denouement">
        <div class="text-black text-3xl font-light italic tracking-[0.5em] opacity-30 uppercase">Unidad</div>
    </div>

    <div id="breathGuide" class="breath-guide">
        <span id="breathText" class="text-[0.6rem] uppercase tracking-[0.4em] opacity-40">Respirar</span>
    </div>

    <div id="uiOverlay" class="ui-overlay">
        <div class="top-settings">
            <div class="section-title">Global</div>
            <button id="toggleBloom" class="toggle-btn active">Efecto Bloom</button>
            <button id="toggleMesh" class="toggle-btn">Mezcla Maestra</button>
            <button id="toggleBreath" class="toggle-btn">Guía Respiratoria</button>
            <button id="toggleAutoUI" class="toggle-btn active">Auto-Ocultar UI</button>

            <div class="section-title">Yoga & Visuales</div>
            <button id="toggleHeart" class="toggle-btn">Sincronización de Latido</button>
            <button id="toggleAlignment" class="toggle-btn">Guía de Alineación</button>
            <button id="toggleWater" class="toggle-btn">Espejo de Agua</button>
            <button id="toggleAsanaEdit" class="toggle-btn">Zonas Asana (Mover)</button>

            <div class="section-title">Ritual & Secuencias</div>
            <button id="startRitual" class="toggle-btn">Ritual Programado (3 etapas)</button>
            <button id="toggleSavasana" class="toggle-btn">Modo Savasana Total</button>
            <div class="slider-group">
                <label class="slider-label">Reloj de Arena (Vignette)</label>
                <input type="range" id="sliderVignette" min="40" max="100" value="60">
            </div>

            <div class="section-title">Dinámicas Colectivas</div>
            <button id="toggleMandala" class="toggle-btn">Modo Mándala (Espejo)</button>
            <button id="toggleVortex" class="toggle-btn">Vórtice de Sincronización</button>
            <button id="toggleAuras" class="toggle-btn">Auras Estáticas</button>
            
            <div class="section-title">Configuración Grupo</div>
            <button id="toggleGroup" class="toggle-btn">Posiciones de Grupo</button>
            <div id="groupSettings" class="slider-group hidden">
                <label class="slider-label">Participantes: <span id="valPersons">10</span></label>
                <input type="range" id="sliderPersons" min="2" max="24" value="10">
                <label class="slider-label">Radio del Círculo</label>
                <input type="range" id="sliderRadius" min="50" max="600" value="300">
                <label class="slider-label">Tamaño de Plaza</label>
                <input type="range" id="sliderSpotSize" min="30" max="250" value="80">
            </div>

            <div class="section-title">Ajustes Dinámicos</div>
            <div class="slider-group">
                <label class="slider-label">Intensidad Luz</label>
                <input type="range" id="sliderSize" min="10" max="180" value="10">
                <label class="slider-label">Persistencia Humo</label>
                <input type="range" id="sliderHalo" min="1" max="10" value="1">
            </div>
            <button id="startTimer" class="toggle-btn">Iniciar Timer (1m)</button>
        </div>

        <div class="text-center mb-4">
            <h1 class="font-serif italic text-2xl tracking-[0.3em] opacity-40">AURA MIST</h1>
            <p id="ritualPhase" class="text-[0.5rem] tracking-[0.4em] mt-1 text-white/40 uppercase hidden">Preparación</p>
            <p id="timerValue" class="text-[0.6rem] tracking-[0.5em] mt-3 hidden">00:00</p>
        </div>

        <div class="palette-group">
            <button class="palette-btn active" data-palette="aurora">Aurora</button>
            <button class="palette-btn" data-palette="ocean">Océano</button>
            <button class="palette-btn" data-palette="forest">Bosque</button>
            <button class="palette-btn" data-palette="fire">Fuego</button>
            <button class="palette-btn" data-palette="nebula">Nebulosa</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const bgCanvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');
        const bgCtx = bgCanvas.getContext('2d');
        const vignette = document.getElementById('vignette');
        
        const uiOverlay = document.getElementById('uiOverlay');
        const breathGuide = document.getElementById('breathGuide');
        const breathText = document.getElementById('breathText');
        const denouementEl = document.getElementById('denouement');
        const timerDisplay = document.getElementById('timerValue');
        const ritualPhaseText = document.getElementById('ritualPhase');

        // Configuración de Estados (Variables Globales)
        window.meshActive = false;
        window.bloomActive = true;
        window.breathActive = false;
        window.autoUIActive = true;
        window.groupActive = false;
        window.mandalaActive = false;
        window.vortexActive = false;
        window.aurasActive = false;
        window.asanaEditActive = false;
        window.alignmentActive = false;
        window.waterActive = false;
        window.savasanaActive = false;
        window.isMeditating = false;
        window.isRitual = false;
        window.heartActive = false;
        
        let width, height, uiTimer, particles = [];
        
        let energySize = 10; 
        let haloAmount = 1; 
        
        let vigSize = 60;
        let basePalette = ['#6366f1', '#a855f7', '#2dd4bf'];
        let activeColors = [...basePalette];
        let numPersons = 10, groupRadius = 300, spotSize = 80;
        let customPositions = [];
        let draggingSpot = null;

        const palettes = {
            aurora: ['#6366f1', '#a855f7', '#2dd4bf'],
            ocean: ['#0ea5e9', '#2dd4bf', '#075985'],
            forest: ['#10b981', '#064e3b', '#f59e0b'],
            fire: ['#f59e0b', '#ef4444', '#7c2d12'],
            nebula: ['#ec4899', '#6366f1', '#1e1b4b']
        };

        function resize() {
            width = canvas.width = bgCanvas.width = window.innerWidth;
            height = canvas.height = bgCanvas.height = window.innerHeight;
            updatePositions();
        }
        window.onresize = resize;

        function updatePositions() {
            if (window.asanaEditActive) return;
            customPositions = [];
            const centerX = width / 2, centerY = height / 2;
            for (let i = 0; i < numPersons; i++) {
                const angle = (i / numPersons) * Math.PI * 2;
                customPositions.push({
                    x: centerX + Math.cos(angle) * groupRadius,
                    y: centerY + Math.sin(angle) * groupRadius,
                    id: i
                });
            }
        }

        const setupToggle = (id, stateVar, callback) => {
            const btn = document.getElementById(id);
            if (!btn) return;
            btn.onclick = () => {
                window[stateVar] = !window[stateVar];
                btn.classList.toggle('active');
                if (callback) callback(window[stateVar]);
            };
        };

        setupToggle('toggleBloom', 'bloomActive', (s) => document.body.classList.toggle('bloom-active'));
        setupToggle('toggleMesh', 'meshActive', (s) => bgCanvas.classList.toggle('active'));
        setupToggle('toggleBreath', 'breathActive', (s) => {
            breathGuide.classList.toggle('active');
            if(s) startBreathCycle();
        });
        setupToggle('toggleAutoUI', 'autoUIActive');
        setupToggle('toggleHeart', 'heartActive', (s) => document.body.classList.toggle('heartbeat-active'));
        setupToggle('toggleAlignment', 'alignmentActive');
        setupToggle('toggleWater', 'waterActive', (s) => canvas.classList.toggle('water-distort'));
        setupToggle('toggleAsanaEdit', 'asanaEditActive');
        setupToggle('toggleMandala', 'mandalaActive');
        setupToggle('toggleVortex', 'vortexActive');
        setupToggle('toggleAuras', 'aurasActive');
        setupToggle('toggleGroup', 'groupActive', (s) => {
            document.getElementById('groupSettings').classList.toggle('hidden');
        });
        
        let preSavasanaVortex = false;

        setupToggle('toggleSavasana', 'savasanaActive', (s) => {
            if(s) {
                preSavasanaVortex = window.vortexActive;
                particles = [];
                window.vortexActive = true;
                document.getElementById('toggleVortex').classList.add('active');
            } else {
                window.vortexActive = preSavasanaVortex;
                if (!window.vortexActive) document.getElementById('toggleVortex').classList.remove('active');
                particles = []; 
            }
        });

        document.getElementById('sliderSize').oninput = (e) => energySize = parseInt(e.target.value);
        document.getElementById('sliderHalo').oninput = (e) => haloAmount = parseInt(e.target.value);
        document.getElementById('sliderVignette').oninput = (e) => {
            vigSize = parseInt(e.target.value);
            updateVignette(vigSize);
        };
        document.getElementById('sliderPersons').oninput = (e) => {
            numPersons = parseInt(e.target.value);
            document.getElementById('valPersons').innerText = numPersons;
            updatePositions();
        };
        document.getElementById('sliderRadius').oninput = (e) => { groupRadius = parseInt(e.target.value); updatePositions(); };
        document.getElementById('sliderSpotSize').oninput = (e) => spotSize = parseInt(e.target.value);

        document.querySelectorAll('.palette-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.palette-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                basePalette = palettes[btn.dataset.palette];
                activeColors = [...basePalette];
            };
        });

        function updateVignette(val) {
            vignette.style.background = `radial-gradient(circle, transparent ${val}%, rgba(0,0,0,0.95) 100%)`;
        }

        function startMeditationSession() {
            if (window.isMeditating) return;
            window.isMeditating = true;
            timerDisplay.classList.remove('hidden');
            let timeLeft = 60;
            const timer = setInterval(() => {
                timeLeft--;
                timerDisplay.innerText = formatTime(timeLeft);
                if (timeLeft <= 0) { clearInterval(timer); endSession(); }
            }, 1000);
        }

        document.getElementById('startTimer').onclick = startMeditationSession;

        document.getElementById('startRitual').onclick = () => {
            if (window.isRitual) return;
            window.isRitual = true;
            ritualPhaseText.classList.remove('hidden');
            timerDisplay.classList.remove('hidden');
            
            const ritualSteps = [
                { name: "Aurora (Calentamiento)", palette: "aurora", time: 10, vig: 70 },
                { name: "Fuego (Vinyasa)", palette: "fire", time: 20, vig: 85 },
                { name: "Océano (Relajación)", palette: "ocean", time: 10, vig: 50 }
            ];

            let stepIdx = 0;
            let stepTimeLeft = ritualSteps[0].time;

            const runStep = () => {
                const step = ritualSteps[stepIdx];
                ritualPhaseText.innerText = step.name;
                basePalette = palettes[step.palette];
                activeColors = [...basePalette];
                updateVignette(step.vig);
                
                const stepTimer = setInterval(() => {
                    stepTimeLeft--;
                    timerDisplay.innerText = formatTime(stepTimeLeft);
                    
                    if(stepTimeLeft <= 0) {
                        clearInterval(stepTimer);
                        stepIdx++;
                        if(stepIdx < ritualSteps.length) {
                            stepTimeLeft = ritualSteps[stepIdx].time;
                            runStep();
                        } else {
                            endSession();
                        }
                    }
                }, 1000);
            };

            runStep();
        };

        function formatTime(s) {
            const mins = Math.floor(s / 60), secs = s % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function endSession() {
            denouementEl.classList.add('active');
            uiOverlay.classList.add('ui-hidden');
            setTimeout(() => {
                denouementEl.classList.remove('active');
                window.isMeditating = window.isRitual = false;
                timerDisplay.classList.add('hidden');
                ritualPhaseText.classList.add('hidden');
                showUI();
                particles = [];
            }, 6000);
        }

        function drawAlignment(pos) {
            if(!window.alignmentActive) return;
            ctx.save();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
            ctx.setLineDash([5, 15]);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pos.x, 0); ctx.lineTo(pos.x, height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, pos.y); ctx.lineTo(width, pos.y);
            ctx.stroke();
            ctx.restore();
        }

        function drawGroupPositions() {
            if (!window.groupActive && !window.aurasActive && !window.asanaEditActive && !window.alignmentActive) return;
            const time = Date.now() * 0.0015;

            customPositions.forEach((pos, i) => {
                if(window.alignmentActive) drawAlignment(pos);

                // Dibujar círculos si Posiciones de Grupo o Edición están activos
                if (window.groupActive || window.asanaEditActive) {
                    ctx.save();
                    ctx.strokeStyle = window.asanaEditActive ? `rgba(255, 255, 255, 0.9)` : `rgba(255, 255, 255, ${0.4 + Math.sin(time*2)*0.2})`;
                    ctx.lineWidth = window.asanaEditActive ? 3 : 1.5;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, spotSize, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                // Dibujar Auras Estáticas
                if (window.aurasActive) {
                    ctx.save();
                    const auraPulse = 0.9 + Math.sin(time + i) * 0.1;
                    const radius = spotSize * 2.5 * auraPulse;
                    const g = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, radius);
                    const color = activeColors[i % activeColors.length];
                    
                    // Convertir HEX a RGBA para el aura
                    let r = 255, g_val = 255, b = 255;
                    if(color.startsWith('#')) {
                        r = parseInt(color.slice(1, 3), 16);
                        g_val = parseInt(color.slice(3, 5), 16);
                        b = parseInt(color.slice(5, 7), 16);
                    }

                    g.addColorStop(0, `rgba(${r}, ${g_val}, ${b}, 0.15)`);
                    g.addColorStop(0.5, `rgba(${r}, ${g_val}, ${b}, 0.05)`);
                    g.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            });
        }

        class Particle {
            constructor(x, y, color, isAmbient = false) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * (isAmbient ? 0.3 : 1.5);
                this.vy = (Math.random() - 0.5) * (isAmbient ? 0.3 : 1.5);
                this.alpha = 0;
                this.targetAlpha = isAmbient ? 0.05 : 0.25;
                this.size = Math.random() * energySize + (isAmbient ? 25 : energySize * 0.4);
                this.color = color;
                this.maxLife = Math.random() * 200 + 350;
                this.life = this.maxLife;
                this.isCenter = false;
            }

            update() {
                if (window.vortexActive) {
                    const dx = width/2 - this.x, dy = height/2 - this.y;
                    this.vx += dx * 0.00014; this.vy += dy * 0.00014;
                }
                this.x += this.vx; this.y += this.vy;
                this.vx *= 0.99; this.vy *= 0.99;
                this.life--;
                const lp = this.life / this.maxLife;
                this.alpha = (lp > 0.8) ? this.alpha + (this.targetAlpha - this.alpha) * 0.05 : lp * this.targetAlpha;
            }

            draw(context, x = this.x, y = this.y) {
                if(window.savasanaActive && !this.isCenter) return;
                context.save();
                context.globalAlpha = this.alpha;
                const grad = context.createRadialGradient(x, y, 0, x, y, this.size);
                grad.addColorStop(0, this.color);
                grad.addColorStop(1, 'transparent');
                context.fillStyle = grad;
                context.beginPath();
                context.arc(x, y, this.size, 0, Math.PI * 2);
                context.fill();
                context.restore();
            }
        }

        function createSplat(x, y, dx, dy, isAmbient = false) {
            if(window.savasanaActive) return;
            const count = isAmbient ? 1 : haloAmount;
            for(let i = 0; i < count; i++) {
                const color = activeColors[Math.floor(Math.random() * activeColors.length)];
                particles.push(new Particle(x, y, color, isAmbient));
            }
        }

        function animate() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = window.bloomActive ? 0.05 : 0.1;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            if(window.meshActive) {
                const meshTime = Date.now() * 0.0003;
                bgCtx.clearRect(0, 0, width, height);
                activeColors.forEach((color, i) => {
                    const x = width / 2 + Math.cos(meshTime + i * 2) * width * 0.4;
                    const y = height / 2 + Math.sin(meshTime * 0.7 + i * 2) * height * 0.4;
                    const size = Math.min(width, height) * 0.8;
                    const g = bgCtx.createRadialGradient(x, y, 0, x, y, size);
                    g.addColorStop(0, color);
                    g.addColorStop(1, 'transparent');
                    bgCtx.globalAlpha = 0.2;
                    bgCtx.fillStyle = g;
                    bgCtx.beginPath();
                    bgCtx.arc(x, y, size, 0, Math.PI * 2);
                    bgCtx.fill();
                });
            }

            drawGroupPositions();

            // Lógica ambiental
            if (window.savasanaActive) {
                if (Math.random() > 0.985) {
                    const p = new Particle(width/2, height/2, "#fff", true);
                    p.isCenter = true;
                    p.targetAlpha = 0.5;
                    p.size = 50 + Math.random() * 50;
                    particles.push(p);
                }
            } else if (Math.random() > 0.975) {
                createSplat(Math.random() * width, Math.random() * height, 0, 0, true);
            }

            particles = particles.filter(p => p.life > 0);
            ctx.globalCompositeOperation = 'screen';
            
            particles.forEach(p => {
                p.update();
                p.draw(ctx);
                
                // Efecto Mándala mejorado
                if (window.mandalaActive) {
                    const centerX = width / 2, centerY = height / 2;
                    const dx = p.x - centerX, dy = p.y - centerY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx);
                    const slices = 6;
                    for(let i = 1; i < slices; i++) {
                        const symAngle = angle + (i * Math.PI * 2) / slices;
                        p.draw(ctx, centerX + Math.cos(symAngle) * dist, centerY + Math.sin(symAngle) * dist);
                    }
                }
            });

            requestAnimationFrame(animate);
        }

        let lastX = 0, lastY = 0;
        const handleInput = (x, y) => {
            showUI();
            if (window.asanaEditActive && draggingSpot !== null) {
                customPositions[draggingSpot].x = x;
                customPositions[draggingSpot].y = y;
                return;
            }
            const dx = x - lastX, dy = y - lastY;
            if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) createSplat(x, y, dx, dy);
            lastX = x; lastY = y;
        };

        window.onmousedown = (e) => {
            if (window.asanaEditActive) {
                customPositions.forEach((pos, i) => {
                    const dist = Math.hypot(e.clientX - pos.x, e.clientY - pos.y);
                    if (dist < spotSize) draggingSpot = i;
                });
            }
        };
        window.onmouseup = () => draggingSpot = null;
        window.onmousemove = (e) => handleInput(e.clientX, e.clientY);
        window.ontouchmove = (e) => handleInput(e.touches[0].clientX, e.touches[0].clientY);

        function showUI() {
            uiOverlay.classList.remove('ui-hidden');
            clearTimeout(uiTimer);
            if (window.autoUIActive) uiTimer = setTimeout(() => uiOverlay.classList.add('ui-hidden'), 8000);
        }

        function startBreathCycle() {
            const cycle = () => {
                if (!window.breathActive) return;
                breathText.innerText = "Inhala";
                setTimeout(() => { if(window.breathActive) breathText.innerText = "Exhala"; }, 4000);
            };
            cycle(); 
            const bInterval = setInterval(() => {
                if(!window.breathActive) clearInterval(bInterval);
                else cycle();
            }, 8000);
        }

        resize(); animate(); updateVignette(60);
    </script>
</body>
</html>
